<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>pnpm Blog</title>
        <link>https://pnpm.io/zh/blog</link>
        <description>pnpm Blog</description>
        <lastBuildDate>Fri, 30 Dec 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <item>
            <title><![CDATA[pnpm 的 2022 年]]></title>
            <link>https://pnpm.io/zh/blog/2022/12/30/yearly-update</link>
            <guid>https://pnpm.io/zh/blog/2022/12/30/yearly-update</guid>
            <pubDate>Fri, 30 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[又是一年年底。 真是艰难的一年。 你们应该知道，我住在乌克兰，由于俄罗斯对我们发动战争，指挥这个项目比往年都难。 尽管如此，今年对pnpm来说是很好的一年。 我们有了很多新用户、贡献者，并且我们实现了许多很棒的功能。]]></description>
            <content:encoded><![CDATA[<p>又是一年年底。 真是艰难的一年。 你们应该知道，我住在乌克兰，由于俄罗斯对我们发动战争，指挥这个项目比往年都难。 尽管如此，今年对pnpm来说是很好的一年。 我们有了很多新用户、贡献者，并且我们实现了许多很棒的功能。</p><p><img loading="lazy" src="/zh/assets/images/2022-review-092f8f0dfe82b760c2e90fd776d82f75.png" width="640" height="640" class="img_Ytbv"></p><p>（上图由 Midjourney 生成。 这只老虎象征虎年）</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="使用方法">使用方法<a href="#使用方法" class="hash-link" aria-label="Direct link to 使用方法" title="Direct link to 使用方法">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="下载统计">下载统计<a href="#下载统计" class="hash-link" aria-label="Direct link to 下载统计" title="Direct link to 下载统计">​</a></h3><p>我今年的目标是在下载量上击败 Lerna。 我们在8月实现了 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=lerna&amp;from=2022-01-01&amp;to=2022-12-30" target="_blank" rel="noopener noreferrer">这个目标</a>:</p><p><img loading="lazy" src="/zh/assets/images/pnpm-vs-lerna-stats-cad28f3b9685ef684c864f919f7f9c5e.png" width="997" height="400" class="img_Ytbv"></p><p>2022 年 pnpm 的下载量比 2021 年多 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2022-12-30" target="_blank" rel="noopener noreferrer">5 倍</a>：</p><p><img loading="lazy" src="/zh/assets/images/download-stats-2022-e4de79bf61e1066802166f9d97cb36ac.png" width="997" height="400" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="文档访问">文档访问<a href="#文档访问" class="hash-link" aria-label="Direct link to 文档访问" title="Direct link to 文档访问">​</a></h3><p>我们使用 Google Analytics 从我们的文档中收集了一些非个性化的统计数据。 在 2022 年，有时我们一周就有超过 20,000 名不同的访客。 这比2021年高10倍！</p><p><img loading="lazy" src="/zh/assets/images/ga-unique-visits-2022-b2e9bf0b6c559a5c59fdbfd8bb1861f0.png" width="778" height="391" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="github-stars">GitHub stars<a href="#github-stars" class="hash-link" aria-label="Direct link to GitHub stars" title="Direct link to GitHub stars">​</a></h3><p>我们的 <a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener noreferrer">主 GitHub 仓库</a> 今年获得了 +7,000 颗星。</p><p><img loading="lazy" src="/zh/assets/images/stars-2022-434ca95e6da688fdff1bb1bf89d6a2d9.png" width="584" height="787" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="贡献者">贡献者<a href="#贡献者" class="hash-link" aria-label="Direct link to 贡献者" title="Direct link to 贡献者">​</a></h3><p>今年我们有很多新的和活跃的贡献者。 这些人在 2022 年合并了至少一个 PR：</p><ul><li><a href="https://github.com/zkochan" target="_blank" rel="noopener noreferrer">Zoltan Kochan</a></li><li><a href="https://github.com/lvqq" target="_blank" rel="noopener noreferrer">chlorine</a></li><li><a href="https://github.com/await-ovo" target="_blank" rel="noopener noreferrer">await-ovo</a></li><li><a href="https://github.com/gluxon" target="_blank" rel="noopener noreferrer">Brandon Cheng</a></li><li><a href="https://github.com/d3lm" target="_blank" rel="noopener noreferrer">Dominic Elm</a></li><li><a href="https://github.com/mcmxcdev" target="_blank" rel="noopener noreferrer">MCMXC</a></li><li><a href="https://github.com/dev-itsheng" target="_blank" rel="noopener noreferrer">那里好脏不可以</a></li><li><a href="https://github.com/HomyeeKing" target="_blank" rel="noopener noreferrer">Homyee King</a></li><li><a href="https://github.com/Shinyaigeek" target="_blank" rel="noopener noreferrer">Shinobu Hayashi</a></li><li><a href="https://github.com/BlackHole1" target="_blank" rel="noopener noreferrer">Black-Hole</a></li><li><a href="https://github.com/kenrick95" target="_blank" rel="noopener noreferrer">Kenrick</a></li><li><a href="https://github.com/weyert" target="_blank" rel="noopener noreferrer">Weyert de Boer</a></li><li><a href="https://github.com/gwhitney" target="_blank" rel="noopener noreferrer">Glen Whitney</a></li><li><a href="https://github.com/chengcyber" target="_blank" rel="noopener noreferrer">Cheng</a></li><li><a href="https://github.com/fireairforce" target="_blank" rel="noopener noreferrer">zoomdong</a></li><li><a href="https://github.com/ufec" target="_blank" rel="noopener noreferrer">thinkhalo</a></li><li><a href="https://github.com/LuciNyan" target="_blank" rel="noopener noreferrer">子瞻 Luci</a></li><li><a href="https://github.com/Spencer17x" target="_blank" rel="noopener noreferrer">spencer17x</a></li><li><a href="https://github.com/liuxingbaoyu" target="_blank" rel="noopener noreferrer">liuxingbaoyu</a></li><li><a href="https://github.com/WhiteKiwi" target="_blank" rel="noopener noreferrer">장지훈</a></li><li><a href="https://github.com/jondlm" target="_blank" rel="noopener noreferrer">Jon de la Motte</a></li><li><a href="https://github.com/Jack-Works" target="_blank" rel="noopener noreferrer">Jack Works</a></li><li><a href="https://github.com/milahu" target="_blank" rel="noopener noreferrer">milahu</a></li><li><a href="https://github.com/David-Collins" target="_blank" rel="noopener noreferrer">David Collins</a></li><li><a href="https://github.com/nikoladev" target="_blank" rel="noopener noreferrer">nikoladev</a></li><li><a href="https://github.com/ibezkrovnyi" target="_blank" rel="noopener noreferrer">Igor Bezkrovnyi</a></li><li><a href="https://github.com/illright" target="_blank" rel="noopener noreferrer">Lev Chelyadinov</a></li><li><a href="https://github.com/javier-garcia-meteologica" target="_blank" rel="noopener noreferrer">javier-garcia-meteologica</a></li></ul><h2 class="anchor anchorWithStickyNavbar_G0xS" id="功能亮点">功能亮点<a href="#功能亮点" class="hash-link" aria-label="Direct link to 功能亮点" title="Direct link to 功能亮点">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="支持无符号链接的-hoisted-的node_modules从v6250开始">支持无符号链接的 hoisted 的<code>node_modules</code>(从<a href="https://github.com/pnpm/pnpm/releases/tag/v6.25.0" target="_blank" rel="noopener noreferrer">v6.25.0</a>开始)<a href="#支持无符号链接的-hoisted-的node_modules从v6250开始" class="hash-link" aria-label="Direct link to 支持无符号链接的-hoisted-的node_modules从v6250开始" title="Direct link to 支持无符号链接的-hoisted-的node_modules从v6250开始">​</a></h3><p>就在 2022 年初，我们增加了对“传统" hoisted 的支持(又称扁平化的 <code>node_modules</code>)。 我们使用 Yarn 的 hoist 算法来创建一个正确的 hoisted <code>node_modules</code>。 这个新设置基本上使 pnpm 可以兼容所有与 npm CLI 兼容的 Node.js 技术栈。</p><p>要使用 hoisted 的 <code>node_modules</code> 目录结构，请在 <code>.npmrc</code> 文件中使用 <code>node-linker=hoisted</code> 设置。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="副作用缓存side-effects-cache-从v700开始">副作用缓存Side effects cache (从<a href="https://github.com/pnpm/pnpm/releases/tag/v7.0.0" target="_blank" rel="noopener noreferrer">v7.0.0</a>开始)<a href="#副作用缓存side-effects-cache-从v700开始" class="hash-link" aria-label="Direct link to 副作用缓存side-effects-cache-从v700开始" title="Direct link to 副作用缓存side-effects-cache-从v700开始">​</a></h3><p>自 v7 以来，默认情况下启用了 <a href="/zh/npmrc#side-effects-cache">副作用缓存side-effect-cache</a> ，因此需要构建的依赖只会被构建一次。 这大大提高了依赖中含有构建脚本的项目的安装速度。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="依赖补丁dependencies-patching从v740开始">依赖补丁Dependencies patching(从<a href="https://github.com/pnpm/pnpm/releases/tag/v7.4.0" target="_blank" rel="noopener noreferrer">v7.4.0</a>开始)<a href="#依赖补丁dependencies-patching从v740开始" class="hash-link" aria-label="Direct link to 依赖补丁dependencies-patching从v740开始" title="Direct link to 依赖补丁dependencies-patching从v740开始">​</a></h3><p>添加了 <a href="/zh/cli/patch"><code>pnpm patch</code></a> 命令，用于修补 <code>node_modules</code>中的依赖项。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="基于时间的依赖解析策略time-based-resolution-strategy从-v7100开始">基于时间的依赖解析策略Time-based resolution strategy(从 <a href="https://github.com/pnpm/pnpm/releases/tag/v7.10.0" target="_blank" rel="noopener noreferrer">v7.10.0</a>开始)<a href="#基于时间的依赖解析策略time-based-resolution-strategy从-v7100开始" class="hash-link" aria-label="Direct link to 基于时间的依赖解析策略time-based-resolution-strategy从-v7100开始" title="Direct link to 基于时间的依赖解析策略time-based-resolution-strategy从-v7100开始">​</a></h3><p>pnpm 添加了一种新的解析模式，会使更新依赖项更加安全。 您可以使用 <a href="https://pnpm.io/npmrc#resolution-mode" target="_blank" rel="noopener noreferrer">resolution-mode</a> 设置，更改解析模式。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="列举依赖中的许可证-listing-licenses-of-dependencies从-v7170开始">列举依赖中的许可证 Listing licenses of dependencies(从 <a href="https://github.com/pnpm/pnpm/releases/tag/v7.17.0" target="_blank" rel="noopener noreferrer">v7.17.0</a>开始)<a href="#列举依赖中的许可证-listing-licenses-of-dependencies从-v7170开始" class="hash-link" aria-label="Direct link to 列举依赖中的许可证-listing-licenses-of-dependencies从-v7170开始" title="Direct link to 列举依赖中的许可证-listing-licenses-of-dependencies从-v7170开始">​</a></h3><p>你可以使用 <a href="/zh/cli/licenses"><code>pnpm licenses list</code></a> 命令来检查已安装软件包的许可证。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm 的 2021 年]]></title>
            <link>https://pnpm.io/zh/blog/2021/12/29/yearly-update</link>
            <guid>https://pnpm.io/zh/blog/2021/12/29/yearly-update</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[现在是年底，对 pnpm 来说是个好年头，所以让我们看看它的进展情况。]]></description>
            <content:encoded><![CDATA[<p>现在是年底，对 pnpm 来说是个好年头，所以让我们看看它的进展情况。</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="使用量">使用量<a href="#使用量" class="hash-link" aria-label="Direct link to 使用量" title="Direct link to 使用量">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="下载统计">下载统计<a href="#下载统计" class="hash-link" aria-label="Direct link to 下载统计" title="Direct link to 下载统计">​</a></h3><p>我今年的目标是在下载量上击败 Bower。 我们在<a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">11月</a>实现了这个目标：</p><p><img loading="lazy" src="/zh/assets/images/pnpm-vs-bower-stats-6ec69a7308f5fbc1433420b1b2f7457f.png" width="976" height="389" class="img_Ytbv"></p><p>2021 年 pnpm 的下载量约为 2020 年的<a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">3倍 </a>：</p><p><img loading="lazy" src="/zh/assets/images/download-stats-2021-1418562cb03abd558c4a6b4b17155227.png" width="983" height="394" class="img_Ytbv"></p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_fVrm"><div class="admonitionHeading_CfVA"><span class="admonitionIcon_Hsjw"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>注意</div><div class="admonitionContent_CXYE"><p>这些统计数据甚至没有衡量 pnpm 可能被安装的所有不同的方式！ 他们只测量了 <a href="https://www.npmjs.com/package/pnpm" target="_blank" rel="noopener noreferrer">pnpm npm package</a> 的下载量。 今年我们还添加了 pnpm 的二进制编译版本，它们的交付的方式是不同的。</p></div></div><h3 class="anchor anchorWithStickyNavbar_G0xS" id="文档访问">文档访问<a href="#文档访问" class="hash-link" aria-label="Direct link to 文档访问" title="Direct link to 文档访问">​</a></h3><p>我们使用 Google Analytics 从我们的文档中收集了一些非个性化的统计数据。 在 2021 年，有时我们每周有超过 2,000 名独立访客。</p><p><img loading="lazy" src="/zh/assets/images/ga-unique-visits-2021-b8bc3649f680565127696c85bdd4b701.png" width="665" height="509" class="img_Ytbv"></p><p>我们的大部分用户来自美国和中国。</p><p><img loading="lazy" src="/zh/assets/images/countries-2021-8eb9625e1798649ee04451dfb10ac851.png" width="585" height="498" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="github-stars">GitHub stars<a href="#github-stars" class="hash-link" aria-label="Direct link to GitHub stars" title="Direct link to GitHub stars">​</a></h3><p>我们的 <a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener noreferrer">主 GitHub 仓库</a> 今年获得了 +5,000 颗星。</p><p><img loading="lazy" src="/zh/assets/images/stars-2021-0061c16f424e33ba0db224d82bcb53f3.png" width="913" height="800" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="新用户">新用户<a href="#新用户" class="hash-link" aria-label="Direct link to 新用户" title="Direct link to 新用户">​</a></h3><p>我们今年最大的新用户是 <a href="https://github.com/pnpm/pnpm.github.io/pull/89" target="_blank" rel="noopener noreferrer">Bytedance</a>（TikTok 背后的公司）。</p><p>此外，许多优秀的开源项目开始使用 pnpm。 有些人转而使用 pnpm 是因为它对 monorepos 的大力支持：</p><ul><li><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener noreferrer">Vue</a></li><li><a href="https://github.com/vitejs/vite" target="_blank" rel="noopener noreferrer">Vite</a></li><li>和 <a href="https://pnpm.io/workspaces#usage-examples" target="_blank" rel="noopener noreferrer">其他</a></li></ul><p>有些人之所以切换为 pnpm，是因为他们喜欢 pnpm 的高效、快速和美观：</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736" target="_blank" rel="noopener noreferrer">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701" target="_blank" rel="noopener noreferrer">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419" target="_blank" rel="noopener noreferrer">Browserslist</a></li></ul><h2 class="anchor anchorWithStickyNavbar_G0xS" id="功能亮点">功能亮点<a href="#功能亮点" class="hash-link" aria-label="Direct link to 功能亮点" title="Direct link to 功能亮点">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="新的锁文件格式自-v600">新的锁文件格式（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0" target="_blank" rel="noopener noreferrer">v6.0.0</a>）<a href="#新的锁文件格式自-v600" class="hash-link" aria-label="Direct link to 新的锁文件格式自-v600" title="Direct link to 新的锁文件格式自-v600">​</a></h3><p>今年第一个也是最重要的变化之一是新的 <code>pnpm-lock.yaml</code> 格式。 这是一个突破性的变化，所以我们不得不发布 v6。 但它是成功的。 旧的锁文件经常导致 Git 冲突。 由于引入了新格式，我们没有收到任何关于 Git 冲突的投诉。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="管理-nodejs-版本自-v6120">管理 Node.js 版本（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0" target="_blank" rel="noopener noreferrer">v6.12.0</a>）<a href="#管理-nodejs-版本自-v6120" class="hash-link" aria-label="Direct link to 管理-nodejs-版本自-v6120" title="Direct link to 管理-nodejs-版本自-v6120">​</a></h3><p>我们发布了一个允许管理 Node.js 版本的新命令（ <code>pnpm env</code> ）。 因此，您可以使用 pnpm 而不是像 nvm 或 Volta 这样的 Node.js 版本管理器。</p><p>此外，pnpm 是作为独立的可执行文件提供的，因此即使系统上没有预装 Node.js，您也可以运行它。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="注入本地依赖自-v6200">注入本地依赖（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0" target="_blank" rel="noopener noreferrer">v6.20.0</a>）<a href="#注入本地依赖自-v6200" class="hash-link" aria-label="Direct link to 注入本地依赖自-v6200" title="Direct link to 注入本地依赖自-v6200">​</a></h3><p>您可以 “inject” 本地依赖项。 默认情况下，本地依赖项被符号链接至 <code>node_modules</code>。但有了这个新功能，你可以指示 pnpm 硬链接包内的文件。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="改进了-peerdependency-问题的报告自-v6240">改进了 peerDependency 问题的报告（自 <a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0" target="_blank" rel="noopener noreferrer">v6.24.0</a>）<a href="#改进了-peerdependency-问题的报告自-v6240" class="hash-link" aria-label="Direct link to 改进了-peerdependency-问题的报告自-v6240" title="Direct link to 改进了-peerdependency-问题的报告自-v6240">​</a></h3><p>PeerDependency 问题曾经被打印为纯文本，很难理解。 它们现在都分组并打印在一个很好的层次结构中。</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="竞争">竞争<a href="#竞争" class="hash-link" aria-label="Direct link to 竞争" title="Direct link to 竞争">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="yarn">Yarn<a href="#yarn" class="hash-link" aria-label="Direct link to Yarn" title="Direct link to Yarn">​</a></h3><p>Yarn 在 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-" target="_blank" rel="noopener noreferrer">v3.1</a> 添加了 pnpm 链接器。 因此 Yarn 可以创建一个类似于 pnpm 创建的 node_modules 目录结构。</p><p>此外，Yarn 团队计划实现内容可寻址存储，以提高磁盘空间效率。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="npm">npm<a href="#npm" class="hash-link" aria-label="Direct link to npm" title="Direct link to npm">​</a></h3><p>Npm 团队决定也采用 pnpm 使用的符号链接的 node_modules 目录结构（相关 <a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md" target="_blank" rel="noopener noreferrer">RFC</a>）。</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="others">Others<a href="#others" class="hash-link" aria-label="Direct link to Others" title="Direct link to Others">​</a></h3><p>用 Zig 编写的 <a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1" target="_blank" rel="noopener noreferrer">Bun</a> 以及 <a href="https://github.com/voltpkg/volt" target="_blank" rel="noopener noreferrer">Volt</a> 都声称比 npm/Yarn/pnpm 更快。 我还没有对这些新的包管理器进行基准测试。</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="未来的计划">未来的计划<a href="#未来的计划" class="hash-link" aria-label="Direct link to 未来的计划" title="Direct link to 未来的计划">​</a></h2><p>更快，更好，最好。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm的node_modules配置选项]]></title>
            <link>https://pnpm.io/zh/blog/2020/10/17/node-modules-configuration-options-with-pnpm</link>
            <guid>https://pnpm.io/zh/blog/2020/10/17/node-modules-configuration-options-with-pnpm</guid>
            <pubDate>Sat, 17 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[创建node_modules目录结构有多种方式。 你一定想要创建最严格的结构，当然如果你当前的项目尚无法支持，你可以配置为不严格的。]]></description>
            <content:encoded><![CDATA[<p>创建node_modules目录结构有多种方式。 你一定想要创建最严格的结构，当然如果你当前的项目尚无法支持，你可以配置为不严格的。</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="默认配置">默认配置<a href="#默认配置" class="hash-link" aria-label="Direct link to 默认配置" title="Direct link to 默认配置">​</a></h2><p>默认情况下，pnpm v5将创建一个“半严格”的node_modules。 “半严格”意味着您的应用程序将只能导入 <code>package.json</code> 中列出的依赖项(但也有例外)。 然而，你所依赖的那些包将能访问任何其他的包。</p><p>默认配置如下所示：</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">; 提升所有包到 node_modules/.pnpm/node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 提升所有名称包含types的包至根，以便Typescript能找到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*types*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 提升所有ESLint相关的包至根</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*eslint*</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_G0xS" id="plugnplay-最严格的配置">Plug'n'Play. 最严格的配置<a href="#plugnplay-最严格的配置" class="hash-link" aria-label="Direct link to Plug'n'Play. 最严格的配置" title="Direct link to Plug'n'Play. 最严格的配置">​</a></h2><p>自v5.9起，pnpm支持 <a href="https://yarnpkg.com/features/pnp" target="_blank" rel="noopener noreferrer">Yarn的Plug'n'Play</a>。 使用PnP，您的应用以及你所依赖的包都只能访问他们声明的依赖关系。 这比设置 <code>hoist = false</code> 更为严格，因为在monorepo中，您的应用甚至连根项目的依赖项也无法访问。</p><p>要使用 Plug'n'Play，请设置以下设置:</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">node-linker=pnp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">symlink=false</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_G0xS" id="严格的模块目录">严格的模块目录<a href="#严格的模块目录" class="hash-link" aria-label="Direct link to 严格的模块目录" title="Direct link to 严格的模块目录">​</a></h2><p>如果您尚未准备好使用PnP，也可以通过将提升配置设置为false来仅允许程序包访问其自身的依赖项，确保其“严格”性：</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">hoist=false</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是，如果您的某些依赖项需要访问它们在依赖项中没有的程序包，则有两种选择：</p><ol><li><p>创建 <code>pnpmfile.js</code> 并使用一个 <a href="/zh/pnpmfile">hook</a> 将缺少的依赖项添加到包的清单中。</p></li><li><p>添加到 <code>hoist-pattern</code> 中。 例如，如果未找到的模块是 <code>babel-core</code>，则将以下设置添加到 <code>.npmrc</code>：</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=babel-core</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ol><h2 class="anchor anchorWithStickyNavbar_G0xS" id="最坏的情况----提升至根">最坏的情况 -- 提升至根<a href="#最坏的情况----提升至根" class="hash-link" aria-label="Direct link to 最坏的情况 -- 提升至根" title="Direct link to 最坏的情况 -- 提升至根">​</a></h2><p>即使使用pnpm的默认配置，某些工具也可能无法工作，默认配置下所有内容都悬挂在虚拟存储的根目录中，而某些软件包则悬挂在根目录中。 在这种情况下，您可以将所有内容或部分依赖关系提升到modules目录的根目录。</p><p>要将所有内容提升到node_modules的根目录：</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">shamefully-hoist=true</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>按匹配规则提升:</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=babel-*</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[平铺的结构不是 node_modules 的唯一实现方式]]></title>
            <link>https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way</link>
            <guid>https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 node_modules 结构。 为什么不是平铺的？ 次级依赖去哪了？]]></description>
            <content:encoded><![CDATA[<p>Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 <code>node_modules</code> 结构。 为什么不是平铺的？ 次级依赖去哪了？</p><blockquote><p>我将默认这篇文章的读者已经熟悉了 npm 与 yarn 创建的平铺的 <code>node_modules</code>。 如果你不明白为什么 npm3 需要开始在 v3 中使用平铺的 <code>node_modules</code>，你可以在这里找到一些背景知识 <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">Why should we use pnpm?</a>。</p></blockquote><p>那么为什么 pnpm 的 <code>node_modules</code> 会如此不同寻常呢？ 让我们创建两个目录，并在其中一个执行 <code>npm add express</code>， 然后在另一个中执行 <code>pnpm add express</code>。 以下是你在第一个目录中的 <code>node_modules</code> 的顶级项目：</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">.bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie-signature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">depd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">destroy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ee-first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">encodeurl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">escape-html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules" target="_blank" rel="noopener noreferrer">这里</a>看到整个目录。</p><p>然后这一个<code>node_modules</code> 是你通过 pnpm 创建的得到的：</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.modules.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules" target="_blank" rel="noopener noreferrer">这里</a>查看。</p><p>那么所有的（次级）依赖去哪了呢？ <code>node_modules</code> 中只有一个叫 <code>.pnpm</code> 的文件夹以及一个叫做 <code>express</code> 的符号链接。 不错，我们只安装了 <code>express</code>，所以它是唯一一个你的应用必须拥有访问权限的包。</p><blockquote><p>要了解关于为什么 pnpm （对依赖项访问控制）的严格把关是件好事，请阅读<a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308" target="_blank" rel="noopener noreferrer">此文</a></p></blockquote><p>让我们看看在 <code>express</code> 中都有些什么：</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▸ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .modules.yaml</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>express</code> 没有 <code>node_modules</code>? <code>express</code> 的所有依赖都去哪里了？</p><p>诀窍是 <code>express</code> 只是一个符号链接。 当 Node.js 解析依赖的时候，它使用这些依赖的真实位置，所以它不保留符号链接。 但是你可能就会问了，<code>express</code> 的真实位置在哪呢？</p><p>在这里：<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express" target="_blank" rel="noopener noreferrer">node_modules/.pnpm/express@4.17.1/node_modules/express</a>。</p><p>OK，所以我们现在知道了 <code>.pnpm/</code> 文件夹的用途。 <code>.pnpm/</code> 以平铺的形式储存着所有的包，所以每个包都可以在这种命名模式的文件夹中被找到：</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们称之为虚拟存储目录。</p><p>这个平铺的结构避免了 npm v2 创建的嵌套 <code>node_modules</code> 引起的长路径问题，但与 npm v3,4,5,6 或 yarn v1 创建的平铺的 <code>node_modules</code> 不同的是，它保留了包之间的相互隔离。</p><p>现在让我们看看 <code>express</code> 的真实位置：</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这是个骗局吗？ 还是没有 <code>node_modules</code>！ pnpm 的 <code>node_modules</code> 结构的第二个诀窍是包的依赖项与依赖包的实际位置位于同一目录级别。 所以 <code>express</code> 的依赖不在 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code> 而是在 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules" target="_blank" rel="noopener noreferrer">.pnpm/express@4.17.1/node_modules/</a>：</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ accepts@1.3.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ array-flatten@1.1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▾ express@4.16.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Readme.md</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="复制代码" title="复制" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>express</code> 所有的依赖都软链至了 <code>node_modules/.pnpm/</code> 中的对应目录。 把 <code>express</code> 的依赖放置在同一级别避免了循环的软链。</p><p>正如你所看到的，即使 pnpm 的 <code>node_modules</code> 结构一开始看起来很奇怪：</p><ol><li>它完全适配了 Node.js。</li><li>包与其依赖被完美地组织在一起。</li></ol><p>有 peer 依赖的包的结构<a href="/zh/how-peers-are-resolved">更加复杂</a>一些，但思路是一样的：使用软链与平铺目录来构建一个嵌套结构。</p>]]></content:encoded>
        </item>
    </channel>
</rss>