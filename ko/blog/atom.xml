<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pnpm.io/ko/blog</id>
    <title>pnpm Blog</title>
    <updated>2022-12-30T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pnpm.io/ko/blog"/>
    <subtitle>pnpm Blog</subtitle>
    <icon>https://pnpm.io/ko/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[The year 2022 for pnpm]]></title>
        <id>https://pnpm.io/ko/blog/2022/12/30/yearly-update</id>
        <link href="https://pnpm.io/ko/blog/2022/12/30/yearly-update"/>
        <updated>2022-12-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[연말이네요. 힘든 한 해였습니다. 아실지 모르겠지만 저는 우크라이나에 살고 있고 러시아와의 전쟁 때문에 예전보다 프로젝트의 진행이 어려웠습니다. 하지만 pnpm에게는 좋은 한 해였습니다. 신규 유저와 기여자가 많이 생겼고 훌륭한 기능들을 많이 구현할 수 있었습니다.]]></summary>
        <content type="html"><![CDATA[<p>연말이네요. 힘든 한 해였습니다. 아실지 모르겠지만 저는 우크라이나에 살고 있고 러시아와의 전쟁 때문에 예전보다 프로젝트의 진행이 어려웠습니다. 하지만 pnpm에게는 좋은 한 해였습니다. 신규 유저와 기여자가 많이 생겼고 훌륭한 기능들을 많이 구현할 수 있었습니다.</p><p><img loading="lazy" src="/ko/assets/images/2022-review-092f8f0dfe82b760c2e90fd776d82f75.png" width="640" height="640" class="img_Ytbv"></p><p>(위 이미지는 Midjourney에 의해 생성되었습니다. 호랑이는 호랑이의 해를 의미합니다)</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="사용">사용<a href="#사용" class="hash-link" aria-label="Direct link to 사용" title="Direct link to 사용">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="다운로드-통계">다운로드 통계<a href="#다운로드-통계" class="hash-link" aria-label="Direct link to 다운로드 통계" title="Direct link to 다운로드 통계">​</a></h3><p>올해 내 목표는 다운로드 수로 Lerna를 이기는 것이 었습니다. 우리는 8월에 이 목표를 달성할 수 있었습니다.</p><p><img loading="lazy" src="/ko/assets/images/pnpm-vs-lerna-stats-cad28f3b9685ef684c864f919f7f9c5e.png" width="997" height="400" class="img_Ytbv"></p><p>pnpm was downloaded more than <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2022-12-30" target="_blank" rel="noopener noreferrer">5 times more</a> in 2022 than in 2021:</p><p><img loading="lazy" src="/ko/assets/images/download-stats-2022-e4de79bf61e1066802166f9d97cb36ac.png" width="997" height="400" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="문서-방문">문서 방문<a href="#문서-방문" class="hash-link" aria-label="Direct link to 문서 방문" title="Direct link to 문서 방문">​</a></h3><p>Google Analytics를 사용하여 문서에서 개인화되지 않은 통계를 수집합니다. In 2022, sometimes we had more than 20,000 unique visitors a week. This is 10 times more than in 2021!</p><p><img loading="lazy" src="/ko/assets/images/ga-unique-visits-2022-b2e9bf0b6c559a5c59fdbfd8bb1861f0.png" width="778" height="391" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="깃허브-스타">깃허브 스타<a href="#깃허브-스타" class="hash-link" aria-label="Direct link to 깃허브 스타" title="Direct link to 깃허브 스타">​</a></h3><p>Our <a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener noreferrer">main GitHub repository</a> received almost +7,000 stars this year.</p><p><img loading="lazy" src="/ko/assets/images/stars-2022-434ca95e6da688fdff1bb1bf89d6a2d9.png" width="584" height="787" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="our-contributors">Our contributors<a href="#our-contributors" class="hash-link" aria-label="Direct link to Our contributors" title="Direct link to Our contributors">​</a></h3><p>We had a lot of new and active contributors this year. These are the people the merge at least one PR in 2022:</p><ul><li><a href="https://github.com/zkochan" target="_blank" rel="noopener noreferrer">Zoltan Kochan</a></li><li><a href="https://github.com/lvqq" target="_blank" rel="noopener noreferrer">chlorine</a></li><li><a href="https://github.com/await-ovo" target="_blank" rel="noopener noreferrer">await-ovo</a></li><li><a href="https://github.com/gluxon" target="_blank" rel="noopener noreferrer">Brandon Cheng</a></li><li><a href="https://github.com/d3lm" target="_blank" rel="noopener noreferrer">Dominic Elm</a></li><li><a href="https://github.com/mcmxcdev" target="_blank" rel="noopener noreferrer">MCMXC</a></li><li><a href="https://github.com/dev-itsheng" target="_blank" rel="noopener noreferrer">那里好脏不可以</a></li><li><a href="https://github.com/HomyeeKing" target="_blank" rel="noopener noreferrer">Homyee King</a></li><li><a href="https://github.com/Shinyaigeek" target="_blank" rel="noopener noreferrer">Shinobu Hayashi</a></li><li><a href="https://github.com/BlackHole1" target="_blank" rel="noopener noreferrer">Black-Hole</a></li><li><a href="https://github.com/kenrick95" target="_blank" rel="noopener noreferrer">Kenrick</a></li><li><a href="https://github.com/weyert" target="_blank" rel="noopener noreferrer">Weyert de Boer</a></li><li><a href="https://github.com/gwhitney" target="_blank" rel="noopener noreferrer">Glen Whitney</a></li><li><a href="https://github.com/chengcyber" target="_blank" rel="noopener noreferrer">Cheng</a></li><li><a href="https://github.com/fireairforce" target="_blank" rel="noopener noreferrer">zoomdong</a></li><li><a href="https://github.com/ufec" target="_blank" rel="noopener noreferrer">thinkhalo</a></li><li><a href="https://github.com/LuciNyan" target="_blank" rel="noopener noreferrer">子瞻 Luci</a></li><li><a href="https://github.com/Spencer17x" target="_blank" rel="noopener noreferrer">spencer17x</a></li><li><a href="https://github.com/liuxingbaoyu" target="_blank" rel="noopener noreferrer">liuxingbaoyu</a></li><li><a href="https://github.com/WhiteKiwi" target="_blank" rel="noopener noreferrer">장지훈</a></li><li><a href="https://github.com/jondlm" target="_blank" rel="noopener noreferrer">Jon de la Motte</a></li><li><a href="https://github.com/Jack-Works" target="_blank" rel="noopener noreferrer">Jack Works</a></li><li><a href="https://github.com/milahu" target="_blank" rel="noopener noreferrer">milahu</a></li><li><a href="https://github.com/David-Collins" target="_blank" rel="noopener noreferrer">David Collins</a></li><li><a href="https://github.com/nikoladev" target="_blank" rel="noopener noreferrer">nikoladev</a></li><li><a href="https://github.com/ibezkrovnyi" target="_blank" rel="noopener noreferrer">Igor Bezkrovnyi</a></li><li><a href="https://github.com/illright" target="_blank" rel="noopener noreferrer">Lev Chelyadinov</a></li><li><a href="https://github.com/javier-garcia-meteologica" target="_blank" rel="noopener noreferrer">javier-garcia-meteologica</a></li></ul><h2 class="anchor anchorWithStickyNavbar_G0xS" id="주요-기능">주요 기능<a href="#주요-기능" class="hash-link" aria-label="Direct link to 주요 기능" title="Direct link to 주요 기능">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="supporting-a-symlinkless-hoisted-node_modules-since-v6250">Supporting a symlinkless hoisted <code>node_modules</code> (since <a href="https://github.com/pnpm/pnpm/releases/tag/v6.25.0" target="_blank" rel="noopener noreferrer">v6.25.0</a>)<a href="#supporting-a-symlinkless-hoisted-node_modules-since-v6250" class="hash-link" aria-label="Direct link to supporting-a-symlinkless-hoisted-node_modules-since-v6250" title="Direct link to supporting-a-symlinkless-hoisted-node_modules-since-v6250">​</a></h3><p>Right at the beginning of 2022, we have added support for the "traditional" hoisted (a.k.a flat <code>node_modules</code>). We use Yarn's hoisting algorithm to create a proper hoisted <code>node_modules</code>. This new setting has basically made pnpm compatible with all Node.js stack that are compatible with npm CLI.</p><p>To use the hoisted <code>node_modules</code> directory structure, use the <code>node-linker=hoisted</code> setting in an <code>.npmrc</code> file.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="side-effects-cache-since-v700">Side effects cache (since <a href="https://github.com/pnpm/pnpm/releases/tag/v7.0.0" target="_blank" rel="noopener noreferrer">v7.0.0</a>)<a href="#side-effects-cache-since-v700" class="hash-link" aria-label="Direct link to side-effects-cache-since-v700" title="Direct link to side-effects-cache-since-v700">​</a></h3><p>Since v7, <a href="/ko/npmrc#side-effects-cache">side-effect-cache</a> is enabled by default, so dependencies that should be built are only built once on a machine. This improves installation speed by a lot in projects that have dependencies with build scripts.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="dependencies-patching-since-v740">Dependencies patching (since <a href="https://github.com/pnpm/pnpm/releases/tag/v7.4.0" target="_blank" rel="noopener noreferrer">v7.4.0</a>)<a href="#dependencies-patching-since-v740" class="hash-link" aria-label="Direct link to dependencies-patching-since-v740" title="Direct link to dependencies-patching-since-v740">​</a></h3><p>The <a href="/ko/cli/patch"><code>pnpm patch</code></a> command have been added for patching dependencies in your <code>node_modules</code>.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="time-based-resolution-strategy-since-v7100">Time-based resolution strategy (since <a href="https://github.com/pnpm/pnpm/releases/tag/v7.10.0" target="_blank" rel="noopener noreferrer">v7.10.0</a>)<a href="#time-based-resolution-strategy-since-v7100" class="hash-link" aria-label="Direct link to time-based-resolution-strategy-since-v7100" title="Direct link to time-based-resolution-strategy-since-v7100">​</a></h3><p>A new resolution mode was added to pnpm, which should make updating dependencies more secure. You can change the resolution mode with the <a href="https://pnpm.io/npmrc#resolution-mode" target="_blank" rel="noopener noreferrer">resolution-mode</a> setting.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="listing-licenses-of-dependencies-since-v7170">Listing licenses of dependencies (since <a href="https://github.com/pnpm/pnpm/releases/tag/v7.17.0" target="_blank" rel="noopener noreferrer">v7.17.0</a>)<a href="#listing-licenses-of-dependencies-since-v7170" class="hash-link" aria-label="Direct link to listing-licenses-of-dependencies-since-v7170" title="Direct link to listing-licenses-of-dependencies-since-v7170">​</a></h3><p>You may now use the <a href="/ko/cli/licenses"><code>pnpm licenses list</code></a> command to check the licenses of the installed packages.</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[pnpm의 2021년]]></title>
        <id>https://pnpm.io/ko/blog/2021/12/29/yearly-update</id>
        <link href="https://pnpm.io/ko/blog/2021/12/29/yearly-update"/>
        <updated>2021-12-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[올해의 끝자락이고 pnpm에게는 좋은 한 해였습니다. 그러니, 어떻게 되었는지 봅시다.]]></summary>
        <content type="html"><![CDATA[<p>올해의 끝자락이고 pnpm에게는 좋은 한 해였습니다. 그러니, 어떻게 되었는지 봅시다.</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="사용량">사용량<a href="#사용량" class="hash-link" aria-label="Direct link to 사용량" title="Direct link to 사용량">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="다운로드-통계">다운로드 통계<a href="#다운로드-통계" class="hash-link" aria-label="Direct link to 다운로드 통계" title="Direct link to 다운로드 통계">​</a></h3><p>올해 저의 목표는 다운로드 수에서 Bower를 이기는 것이 었습니다. 우리는 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;package=bower&amp;from=2021-01-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">11월</a>에 그 목표를 달성할 수 있었습니다.</p><p><img loading="lazy" src="/ko/assets/images/pnpm-vs-bower-stats-6ec69a7308f5fbc1433420b1b2f7457f.png" width="976" height="389" class="img_Ytbv"></p><p>pnpm은 2020년에 비해 2021년에는 <a href="https://npm-stat.com/charts.html?package=pnpm&amp;from=2016-12-01&amp;to=2021-12-29" target="_blank" rel="noopener noreferrer">약 3배 더 많이</a> 다운로드되었습니다.</p><p><img loading="lazy" src="/ko/assets/images/download-stats-2021-1418562cb03abd558c4a6b4b17155227.png" width="983" height="394" class="img_Ytbv"></p><p>:::참고</p><p>이 통계는 pnpm이 설치될 수 있는 모든 다양한 방법을 측정하지도 않습니다! 그들은 단지 <a href="https://www.npmjs.com/package/pnpm" target="_blank" rel="noopener noreferrer">pnpm npm 패키지</a>의 다운로드만 측정합니다. 올해 우리는 또한 pnpm의 컴파일 된 바이너리 버전을 추가하며 이는 다른식으로 출하됩니다.</p><p>:::</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="문서-방문">문서 방문<a href="#문서-방문" class="hash-link" aria-label="Direct link to 문서 방문" title="Direct link to 문서 방문">​</a></h3><p>Google Analytics를 사용하여 문서에서 개인화되지 않은 통계를 수집합니다. 2021년에는 때때로 일주일에 2,000명 이상의 고유 방문자가 있었습니다.</p><p><img loading="lazy" src="/ko/assets/images/ga-unique-visits-2021-b8bc3649f680565127696c85bdd4b701.png" width="665" height="509" class="img_Ytbv"></p><p>대부분의 사용자는 미국과 중국 출신입니다.</p><p><img loading="lazy" src="/ko/assets/images/countries-2021-8eb9625e1798649ee04451dfb10ac851.png" width="585" height="498" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="깃허브-스타">깃허브 스타<a href="#깃허브-스타" class="hash-link" aria-label="Direct link to 깃허브 스타" title="Direct link to 깃허브 스타">​</a></h3><p><a href="https://github.com/pnpm/pnpm" target="_blank" rel="noopener noreferrer">주요 GitHub 저장소</a>는 올해 +5,000개의 별을 받았습니다.</p><p><img loading="lazy" src="/ko/assets/images/stars-2021-0061c16f424e33ba0db224d82bcb53f3.png" width="913" height="800" class="img_Ytbv"></p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="신규-사용자">신규 사용자<a href="#신규-사용자" class="hash-link" aria-label="Direct link to 신규 사용자" title="Direct link to 신규 사용자">​</a></h3><p>올해 가장 큰 신규 사용자는 <a href="https://github.com/pnpm/pnpm.github.io/pull/89" target="_blank" rel="noopener noreferrer">Bytedance</a> (TikTok 뒤에 있는 회사)입니다.</p><p>또한 많은 훌륭한 오픈 소스 프로젝트에서 pnpm을 사용하기 시작했습니다. 일부는 모노레포에 대한 뛰어난 지원 때문에 pnpm으로 전환했습니다.</p><ul><li><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener noreferrer">Vue</a></li><li><a href="https://github.com/vitejs/vite" target="_blank" rel="noopener noreferrer">Vite</a></li><li>및 <a href="https://pnpm.io/workspaces#usage-examples" target="_blank" rel="noopener noreferrer">다른 것들</a></li></ul><p>일부는 pnpm이 얼마나 효율적이고 빠르며 아름다운지를 좋아하기 때문에 전환했습니다.</p><ul><li><a href="https://twitter.com/Autoprefixer/status/1476226146488692736" target="_blank" rel="noopener noreferrer">Autoprefixer</a></li><li><a href="https://twitter.com/PostCSS/status/1470438664006258701" target="_blank" rel="noopener noreferrer">PostCSS</a></li><li><a href="https://twitter.com/Browserslist/status/1468264308308156419" target="_blank" rel="noopener noreferrer">Browserslist</a></li></ul><h2 class="anchor anchorWithStickyNavbar_G0xS" id="주요-기능">주요 기능<a href="#주요-기능" class="hash-link" aria-label="Direct link to 주요 기능" title="Direct link to 주요 기능">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="새로운-locfile-형식-v600-이후">새로운 locfile 형식 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.0.0" target="_blank" rel="noopener noreferrer">v6.0.0</a> 이후)<a href="#새로운-locfile-형식-v600-이후" class="hash-link" aria-label="Direct link to 새로운-locfile-형식-v600-이후" title="Direct link to 새로운-locfile-형식-v600-이후">​</a></h3><p>올해 처음이자 가장 중요한 변경 사항 중 하나는 새로운 <code>pnpm-lock.yaml</code> 형식입니다. 이것은 브레이킹 체인지였기 때문에 v6을 출시해야 했습니다. 그러나 그것은 성공적이었습니다. 이전 lockfile은 Git 충돌을 자주 일으켰습니다. 새로운 형식이 도입된 이후로 Git 충돌에 대한 불만은 접수되지 않았습니다.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="nodejs-버전-관리-v6120-이후">Node.js 버전 관리 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.12.0" target="_blank" rel="noopener noreferrer">v6.12.0</a> 이후)<a href="#nodejs-버전-관리-v6120-이후" class="hash-link" aria-label="Direct link to nodejs-버전-관리-v6120-이후" title="Direct link to nodejs-버전-관리-v6120-이후">​</a></h3><p>Node.js 버전을 관리할 수 있는 새로운 명령어 (<code>pnpm env</code>)를 출하했습니다. 따라서 nvm 또는 Volta와 같은 Node.js 버전 관리자 대신 pnpm을 사용할 수 있습니다.</p><p>또한 pnpm은 독립 실행형 실행 파일로 제공되므로 시스템에 Node.js가 사전 설치되어 있지 않아도 실행할 수 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="로컬-의존성-주입-v6200-이후">로컬 의존성 주입 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.20.0" target="_blank" rel="noopener noreferrer">v6.20.0</a> 이후)<a href="#로컬-의존성-주입-v6200-이후" class="hash-link" aria-label="Direct link to 로컬-의존성-주입-v6200-이후" title="Direct link to 로컬-의존성-주입-v6200-이후">​</a></h3><p>여러분은 로컬 의존성을 "주입"할 수 있습니다. 기본적으로 로컬 의존성은 <code>node_modules</code>에 심볼릭 링크되지만 이 새로운 기능을 사용하면 pnpm에 패키지 파일을 하드 링크하도록 지시할 수 있습니다.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="피어-의존성-문제에-대한-보고-기능-개선-v6240-이후">피어 의존성 문제에 대한 보고 기능 개선 (<a href="https://github.com/pnpm/pnpm/releases/tag/v6.24.0" target="_blank" rel="noopener noreferrer">v6.24.0</a> 이후)<a href="#피어-의존성-문제에-대한-보고-기능-개선-v6240-이후" class="hash-link" aria-label="Direct link to 피어-의존성-문제에-대한-보고-기능-개선-v6240-이후" title="Direct link to 피어-의존성-문제에-대한-보고-기능-개선-v6240-이후">​</a></h3><p>피어 의존성 문제는 일반 텍스트로 출력되어 이해하기 어려웠습니다. 이제 모두 그룹화되어 멋진 계층 구조로 출력됩니다.</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="경쟁">경쟁<a href="#경쟁" class="hash-link" aria-label="Direct link to 경쟁" title="Direct link to 경쟁">​</a></h2><h3 class="anchor anchorWithStickyNavbar_G0xS" id="yarn">Yarn<a href="#yarn" class="hash-link" aria-label="Direct link to Yarn" title="Direct link to Yarn">​</a></h3><p>Yarn은 <a href="https://dev.to/arcanis/yarn-31-corepack-esm-pnpm-optional-packages--3hak#new-install-mode-raw-pnpm-endraw-" target="_blank" rel="noopener noreferrer">v3.1</a>에서 pnpm 링커를 추가했습니다. 따라서 Yarn은 pnpm이 생성하는 것과 유사한 노드 모듈 디렉토리 구조를 생성할 수 있습니다.</p><p>또한 Yarn 팀은 디스크 공간 효율성을 높이기 위해 콘텐츠 주소 지정 가능 스토리지를 구현할 계획입니다.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="npm">npm<a href="#npm" class="hash-link" aria-label="Direct link to npm" title="Direct link to npm">​</a></h3><p>npm 팀은 pnpm이 사용하는 심볼릭 링크된 node-modules 디렉토리 구조 (<a href="https://github.com/npm/rfcs/blob/main/accepted/0042-isolated-mode.md" target="_blank" rel="noopener noreferrer">RFC</a>와 관련된)도 채택하기로 결정했습니다.</p><h3 class="anchor anchorWithStickyNavbar_G0xS" id="기타">기타<a href="#기타" class="hash-link" aria-label="Direct link to 기타" title="Direct link to 기타">​</a></h3><p>Zig로 작성된 <a href="https://twitter.com/jarredsumner/status/1473416431291174912/photo/1" target="_blank" rel="noopener noreferrer">Bun</a>과 Rust로 작성된 <a href="https://github.com/voltpkg/volt" target="_blank" rel="noopener noreferrer">Volt</a> 모두 npm/Yarn/pnpm보다 빠르다고 주장합니다. 이 새로운 패키지 관리자를 아직 벤치마킹하지 않았습니다.</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="향후-계획">향후 계획<a href="#향후-계획" class="hash-link" aria-label="Direct link to 향후 계획" title="Direct link to 향후 계획">​</a></h2><p>더 빠르고, 더 좋고, 최고가 될 것 입니다.</p>]]></content>
        <author>
            <name>졸탄 코찬</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[pnpm을 사용한 노드 모듈 구성 옵션]]></title>
        <id>https://pnpm.io/ko/blog/2020/10/17/node-modules-configuration-options-with-pnpm</id>
        <link href="https://pnpm.io/ko/blog/2020/10/17/node-modules-configuration-options-with-pnpm"/>
        <updated>2020-10-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[nodemodules 디렉토리를 만드는 방법에는 여러 가지가 있습니다. 여러분의 목표는 가장 엄격한 것을 만드는 것이지만 그것이 가능하지 않다면, 느슨한 nodemodules을 만드는 옵션도 있습니다.]]></summary>
        <content type="html"><![CDATA[<p>node_modules 디렉토리를 만드는 방법에는 여러 가지가 있습니다. 여러분의 목표는 가장 엄격한 것을 만드는 것이지만 그것이 가능하지 않다면, 느슨한 node_modules을 만드는 옵션도 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_G0xS" id="기본-설정">기본 설정<a href="#기본-설정" class="hash-link" aria-label="Direct link to 기본 설정" title="Direct link to 기본 설정">​</a></h2><p>기본적으로 pnpm v5는 반만 엄격한 node_modules를 만듭니다. 반만 엄격하다는 것은 응용 프로그램이 <code>package.json</code>에 의존성으로 추가된 패키지만 요구할 수 있음을 의미합니다 (몇 가지 예외는 제외). 그러나 여러분의 의존성은 모든 패키지에 접근할 수 있습니다.</p><p>기본 구성은 다음과 같습니다.</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">; 모든 패키지는  node_modules/.pnpm/node_modules에 호이스팅되어 있습니다</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 모든 타입은 타입스크립트를 행복하게 만들기 위해 루트로 호이스팅되어 있습니다</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*types*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 모든 ESLint와 관련된 패키지는 마찬가지로 호이스팅 되어 있습니다</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=*eslint*</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_G0xS" id="plugnplay-가장-엄격한-구성">Plug'n'Play. 가장 엄격한 구성<a href="#plugnplay-가장-엄격한-구성" class="hash-link" aria-label="Direct link to Plug'n'Play. 가장 엄격한 구성" title="Direct link to Plug'n'Play. 가장 엄격한 구성">​</a></h2><p>pnpm은 v5.9 부터 <a href="https://yarnpkg.com/features/pnp" target="_blank" rel="noopener noreferrer">Yarn의 Plug'n ' Play</a> 를 지원합니다. PnP를 사용하면 애플리케이션과 애플리케이션의 의존성이 선언된 의존성에만 접근할 수 있습니다. 이것은 monorepo 내부에서 애플리케이션이 루트 프로젝트의 의존성에도 접근할 수 없기 때문에 <code>hoist=false</code> 로 설정하는 것보다 훨씬 더 엄격합니다.</p><p>Plug'n'Play를 사용하려면 다음 설정을 설정하세요.</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">node-linker=pnp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">symlink=false</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_G0xS" id="엄격하고-전통적인-모듈-디렉토리">엄격하고 전통적인 모듈 디렉토리<a href="#엄격하고-전통적인-모듈-디렉토리" class="hash-link" aria-label="Direct link to 엄격하고 전통적인 모듈 디렉토리" title="Direct link to 엄격하고 전통적인 모듈 디렉토리">​</a></h2><p>아직 PnP를 사용할 준비가 되지 않은 경우에도 여전히 엄격할 수 있으며 호이스팅 구성을 false로 설정하여 패키지가 자체 의존성에만 접근하도록 허용할 수 있습니다.</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">hoist=false</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>그러나 의존성 중 일부가 그들의 의존성에 없는 패키지에 접근하려고 하는 경우 두 가지 옵션이 있습니다.</p><ol><li><p><code>pnpmfile.js</code>를 만들고 <a href="/ko/pnpmfile">hook</a>를 사용하여 패키지의 매니페스트에 누락된 의존성을 추가합니다.</p></li><li><p><code>hoist-pattern</code> 설정에 패턴을 추가합니다. 예를 들어, 그 찾을 수 없는 모듈이 <code>babel-core</code>이면, 다음 설정을 <code>.npmrc</code>추가합니다.</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">hoist-pattern[]=babel-core</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ol><h2 class="anchor anchorWithStickyNavbar_G0xS" id="최악의-경우---루트로-호이스팅">최악의 경우 - 루트로 호이스팅<a href="#최악의-경우---루트로-호이스팅" class="hash-link" aria-label="Direct link to 최악의 경우 - 루트로 호이스팅" title="Direct link to 최악의 경우 - 루트로 호이스팅">​</a></h2><p>일부 도구는 모든 것을 가상 저장소의 루트에 호이스팅하고 일부 패키지를 루트에 호이스팅하는 pnpm의 기본 구성에서도 작동하지 않을 수 있습니다. 이 경우, 모든 항목 또는 의존성의 하위 집합을 모듈 디렉터리의 루트로 호이스팅할 수 있습니다.</p><p>모든 항목을 node_modules의 루트로 호이스팅하기:</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">shamefully-hoist=true</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>패턴과 일치하는 패키지만 호이스팅하기:</p><div class="language-ini codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-ini codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">public-hoist-pattern[]=babel-*</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[평탄한 node_modules가 유일한 방법은 아닙니다.]]></title>
        <id>https://pnpm.io/ko/blog/2020/05/27/flat-node-modules-is-not-the-only-way</id>
        <link href="https://pnpm.io/ko/blog/2020/05/27/flat-node-modules-is-not-the-only-way"/>
        <updated>2020-05-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[pnpm의 신규 사용자들이 pnpm에서 생성하는 node_modules의 특이한 구조에 대해 자주 질문합니다. 왜 플랫이 아닌가요? 모든 하위 의존성들은 어디에 있나요?]]></summary>
        <content type="html"><![CDATA[<p>pnpm의 신규 사용자들이 pnpm에서 생성하는 <code>node_modules</code>의 특이한 구조에 대해 자주 질문합니다. 왜 플랫이 아닌가요? 모든 하위 의존성들은 어디에 있나요?</p><blockquote><p>저는 이 기사의 독자들이 npm과 Yarn에서 생성하는 <code>node_modules</code>에 이미 익숙하다고 가정합니다. 만약 npm 3이 플랫 <code>node_modules</code> 를 사용하여 v3 에서 시작해야 하는 이유를 이해하지 못하는 경우, <a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">에서 몇 가지 사전 히스토리를 찾을 수 있습니다.</a>.</p></blockquote><p>그러면 왜 pnpm의 <code>node_modules</code> 디렉토리는 특이할까요? 두 개의 디렉토리를 만들고 그 중 하나에서 <code>npm add express</code> 을 실행하고 다른 하나에서 <code>pnpm add express</code>을 실행합니다. 다음은 첫 번째 디렉토리의 <code>node_modules</code>에서 얻을 수 있는 상위 항목입니다.</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">.bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie-signature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cookie</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">depd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">destroy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ee-first</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">encodeurl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">escape-html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>여러분은 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules" target="_blank" rel="noopener noreferrer">여기</a>에서 전체 디렉토리를 볼 수 있습니다.</p><p>그리고 이것이 pnpm에 의해 만들어진 <code>node_modules</code>에서 얻은 항목입니다.</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.modules.yaml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">express</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>여러분은 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules" target="_blank" rel="noopener noreferrer">여기</a>에서 전체 디렉토리를 확인할 수 있습니다.</p><p>그래서 모든 의존성들은 어디에 있을까요? <code>node_modules</code> 에는 <code>.pnpm</code> 이라는 하나의 폴더뿐이며 <code>express</code>라는 심볼릭 링크만 있습니다. 음, 우리는 오직 <code>express</code>만 설치했으므로 당신의 애플리케이션이 접근할 수 있는 유일한 패키지입니다.</p><blockquote><p>왜 pnpm의 엄격함이 좋은지 <a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308" target="_blank" rel="noopener noreferrer">여기</a>서 자세히 읽어보세요.</p></blockquote><p><code>express</code>안에 무엇이 있는지 봅시다.</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▸ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .modules.yaml</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>express</code> 에는 <code>node_modules</code>가 없네요? <code>express</code>의 모든 의존성들은 어디에 있을까요?</p><p>트릭은 <code>express</code>가 단지 심볼릭 링크라는 것입니다. Node.js는 의존성을 해결할 때, 실제 위치를 사용하므로 심볼릭 링크를 유지하지 않습니다. 하지만 <code>express</code>의 실제 위치가 어디냐고 당신은 물어볼 수 있겠죠?</p><p>여기: <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express" target="_blank" rel="noopener noreferrer">node_modules/.pnpm/express@4.17.1/node_modules/express</a>.</p><p>자, 이제 우리는 <code>.pnpm/</code> 폴더의 목적을 알고 있습니다. <code>.pnpm/</code> 는 모든 패키지를 플랫 폴더 구조로 저장하므로 모든 패키지는 다음 패턴으로 이름이 지정된 폴더에서 찾을 수 있습니다.</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm/&lt;이름&gt;@&lt;버전&gt;/node_modules/&lt;이름&gt;</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>우리는 이것을 가상 저장소 디렉토리라고 부릅니다.</p><p>이러한 평탄한 구조는 npm v2에 의해 만들어진 중첩 형식의 <code>node_modules </code> 에서의 긴 경로 문제를 회피하지만, npm v3,4,5,6 또는 Yarn v1에 의해 생성된 평탄한 <code>node _modules</code>와는 달리 패키지를 격리된 상태로 유지합니다.</p><p>이제 <code>express</code>의 실제 위치를 알아보겠습니다.</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Readme.md</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>사기일까요? <code>node _modules</code>가 여전히 없네요! pnpm에서 <code>node_modules</code> 구조의 두 번째 트릭은 패키지의 의존성들이 의존 패키지의 실제 위치와 동일한 디렉토리 레벨에 있다는 것입니다. 따라서 <code>express</code>의 의존성들은 <code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>에 있는 것이 아니라 <a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules" target="_blank" rel="noopener noreferrer">.pnpm/express@4.17.1/node_modules/</a>에 있습니다:</p><div class="language-text codeBlockContainer_qBuI theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_s4cj"><pre tabindex="0" class="prism-code language-text codeBlock_ZB_v thin-scrollbar"><code class="codeBlockLines_iNkr"><span class="token-line" style="color:#393A34"><span class="token plain">▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ▾ .pnpm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ accepts@1.3.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▸ array-flatten@1.1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ▾ express@4.16.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ▾ node_modules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ accepts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ array-flatten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ body-parser</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ content-disposition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▸ etag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ▾ express</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ▸ lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            History.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index.js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LICENSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            package.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Readme.md</span><br></span></code></pre><div class="buttonGroup_MJM4"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_rG_2" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_l0xu"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_DXTq"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>express</code>의 모든 의존성들은 <code>node_modules/.pnpm/</code> 내의 적절한 디렉토리에 대한 심볼릭 링크입니다. <code>express</code>의 의존성들을 한 단계 위로 배치하면 순환 심볼릭 링크를 피할 수 있습니다.</p><p>보시다시피 pnpm의 <code>node_modules</code> 구조가 처음에는 특이한 것 같죠:</p><ol><li>Node.js와 완전히 호환됩니다.</li><li>패키지는 의존성과 함께 멋지게 그룹화됩니다.</li></ol><p>피어 의존성을 가진 패키지의 경우 구조가 <a href="/ko/how-peers-are-resolved">조금 더 복잡</a>하지만 생각은 동일합니다: 평탄한 디렉토리 구조로 중첩구조를 만들기 위해 심볼릭 링크를 사용하기</p>]]></content>
        <author>
            <name>Zoltan Kochan</name>
            <uri>http://twitter.com/zoltankochan</uri>
        </author>
    </entry>
</feed>