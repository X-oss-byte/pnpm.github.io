"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2386],{9613:(e,n,o)=>{o.d(n,{Zo:()=>p,kt:()=>k});var t=o(9496);function r(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function a(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,t)}return o}function s(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?a(Object(o),!0).forEach((function(n){r(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function i(e,n){if(null==e)return{};var o,t,r=function(e,n){if(null==e)return{};var o,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)o=a[t],n.indexOf(o)>=0||(r[o]=e[o]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)o=a[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=t.createContext({}),d=function(e){var n=t.useContext(l),o=n;return e&&(o="function"==typeof e?e(n):s(s({},n),e)),o},p=function(e){var n=d(e.components);return t.createElement(l.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var o=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=d(o),c=r,k=m["".concat(l,".").concat(c)]||m[c]||u[c]||a;return o?t.createElement(k,s(s({ref:n},p),{},{components:o})):t.createElement(k,s({ref:n},p))}));function k(e,n){var o=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=o.length,s=new Array(a);s[0]=c;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[m]="string"==typeof e?e:r,s[1]=i;for(var d=2;d<a;d++)s[d]=o[d];return t.createElement.apply(null,s)}return t.createElement.apply(null,o)}c.displayName="MDXCreateElement"},4234:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>k,frontMatter:()=>i,metadata:()=>d,toc:()=>m});var t=o(1966),r=o(9836),a=(o(9496),o(9613)),s=["components"],i={id:"symlinked-node-modules-structure",title:"Symlinked `node_modules` structure"},l=void 0,d={unversionedId:"symlinked-node-modules-structure",id:"version-8.x/symlinked-node-modules-structure",title:"Symlinked `node_modules` structure",description:"This article only describes how pnpm's node_modules are structured when there are no packages with peer dependencies. For the more complex scenario of dependencies with peers, see how peers are resolved.",source:"@site/i18n/id/docusaurus-plugin-content-docs/version-8.x/symlinked-node-modules-structure.md",sourceDirName:".",slug:"/symlinked-node-modules-structure",permalink:"/id/symlinked-node-modules-structure",draft:!1,editUrl:"https://translate.pnpm.io/project/pnpm/id",tags:[],version:"8.x",frontMatter:{id:"symlinked-node-modules-structure",title:"Symlinked `node_modules` structure"},sidebar:"version-8.x/docs",previous:{title:"Batasan",permalink:"/id/limitations"},next:{title:"How peers are resolved",permalink:"/id/how-peers-are-resolved"}},p={},m=[],u={toc:m},c="wrapper";function k(e){var n=e.components,o=(0,r.Z)(e,s);return(0,a.kt)(c,(0,t.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"This article only describes how pnpm's ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," are structured when there are no packages with peer dependencies. For the more complex scenario of dependencies with peers, see ",(0,a.kt)("a",{parentName:"p",href:"/id/how-peers-are-resolved"},"how peers are resolved"),".")),(0,a.kt)("p",null,"pnpm's ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," layout uses symbolic links to create a nested structure of dependencies."),(0,a.kt)("p",null,"Every file of every package inside ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," is a hard link to the content-addressable store. Let's say you install ",(0,a.kt)("inlineCode",{parentName:"p"},"foo@1.0.0")," that depends on ",(0,a.kt)("inlineCode",{parentName:"p"},"bar@1.0.0"),". pnpm will hard link both packages to ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"node_modules\n\u2514\u2500\u2500 .pnpm\n    \u251c\u2500\u2500 bar@1.0.0\n    \u2502   \u2514\u2500\u2500 node_modules\n    \u2502       \u2514\u2500\u2500 bar -> <store>/bar\n    \u2502           \u251c\u2500\u2500 index.js\n    \u2502           \u2514\u2500\u2500 package.json\n    \u2514\u2500\u2500 foo@1.0.0\n        \u2514\u2500\u2500 node_modules\n            \u2514\u2500\u2500 foo -> <store>/foo\n                \u251c\u2500\u2500 index.js\n                \u2514\u2500\u2500 package.json\n")),(0,a.kt)("p",null,'These are the only "real" files in ',(0,a.kt)("inlineCode",{parentName:"p"},"node_modules"),". Once all the packages are hard linked to ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules"),", symbolic links are created to build the nested dependency graph structure."),(0,a.kt)("p",null,"As you might have noticed, both packages are hard linked into a subfolder inside a ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," folder (",(0,a.kt)("inlineCode",{parentName:"p"},"foo@1.0.0/node_modules/foo"),"). This is needed to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"allow packages to import themselves.")," ",(0,a.kt)("inlineCode",{parentName:"li"},"foo")," should be able to ",(0,a.kt)("inlineCode",{parentName:"li"},"require('foo/package.json')")," or ",(0,a.kt)("inlineCode",{parentName:"li"},'import * as package from "foo/package.json"'),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"avoid circular symlinks.")," Dependencies of packages are placed in the same folder in which the dependent packages are. For Node.js it doesn't make a difference whether dependencies are inside the package's ",(0,a.kt)("inlineCode",{parentName:"li"},"node_modules")," or in any other ",(0,a.kt)("inlineCode",{parentName:"li"},"node_modules")," in the parent directories.")),(0,a.kt)("p",null,"The next stage of installation is symlinking dependencies. ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," is going to be symlinked to the ",(0,a.kt)("inlineCode",{parentName:"p"},"foo@1.0.0/node_modules")," folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"node_modules\n\u2514\u2500\u2500 .pnpm\n    \u251c\u2500\u2500 bar@1.0.0\n    \u2502   \u2514\u2500\u2500 node_modules\n    \u2502       \u2514\u2500\u2500 bar -> <store>/bar\n    \u2514\u2500\u2500 foo@1.0.0\n        \u2514\u2500\u2500 node_modules\n            \u251c\u2500\u2500 foo -> <store>/foo\n            \u2514\u2500\u2500 bar -> ../../bar@1.0.0/node_modules/bar\n")),(0,a.kt)("p",null,"Next, direct dependencies are handled. ",(0,a.kt)("inlineCode",{parentName:"p"},"foo")," is going to be symlinked into the root ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," folder because ",(0,a.kt)("inlineCode",{parentName:"p"},"foo")," is a dependency of the project:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"node_modules\n\u251c\u2500\u2500 foo -> ./.pnpm/foo@1.0.0/node_modules/foo\n\u2514\u2500\u2500 .pnpm\n    \u251c\u2500\u2500 bar@1.0.0\n    \u2502   \u2514\u2500\u2500 node_modules\n    \u2502       \u2514\u2500\u2500 bar -> <store>/bar\n    \u2514\u2500\u2500 foo@1.0.0\n        \u2514\u2500\u2500 node_modules\n            \u251c\u2500\u2500 foo -> <store>/foo\n            \u2514\u2500\u2500 bar -> ../../bar@1.0.0/node_modules/bar\n")),(0,a.kt)("p",null,"This is a very simple example. However, the layout will maintain this structure regardless of the number of dependencies and the depth of the dependency graph."),(0,a.kt)("p",null,"Let's add ",(0,a.kt)("inlineCode",{parentName:"p"},"qar@2.0.0")," as a dependency of ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"foo"),". This is how the new structure will look:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"node_modules\n\u251c\u2500\u2500 foo -> ./.pnpm/foo@1.0.0/node_modules/foo\n\u2514\u2500\u2500 .pnpm\n    \u251c\u2500\u2500 bar@1.0.0\n    \u2502   \u2514\u2500\u2500 node_modules\n    \u2502       \u251c\u2500\u2500 bar -> <store>/bar\n    \u2502       \u2514\u2500\u2500 qar -> ../../qar@2.0.0/node_modules/qar\n    \u251c\u2500\u2500 foo@1.0.0\n    \u2502   \u2514\u2500\u2500 node_modules\n    \u2502       \u251c\u2500\u2500 foo -> <store>/foo\n    \u2502       \u251c\u2500\u2500 bar -> ../../bar@1.0.0/node_modules/bar\n    \u2502       \u2514\u2500\u2500 qar -> ../../qar@2.0.0/node_modules/qar\n    \u2514\u2500\u2500 qar@2.0.0\n        \u2514\u2500\u2500 node_modules\n            \u2514\u2500\u2500 qar -> <store>/qar\n")),(0,a.kt)("p",null,"As you may see, even though the graph is deeper now (",(0,a.kt)("inlineCode",{parentName:"p"},"foo > bar > qar"),"), the directory depth in the file system is still the same."),(0,a.kt)("p",null,"This layout might look weird at first glance, but it is completely compatible with Node's module resolution algorithm! When resolving modules, Node ignores symlinks, so when ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," is required from ",(0,a.kt)("inlineCode",{parentName:"p"},"foo@1.0.0/node_modules/foo/index.js"),", Node does not use ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," at ",(0,a.kt)("inlineCode",{parentName:"p"},"foo@1.0.0/node_modules/bar"),", but instead, ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," is resolved to its real location (",(0,a.kt)("inlineCode",{parentName:"p"},"bar@1.0.0/node_modules/bar"),"). As a consequence, ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," can also resolve its dependencies which are in ",(0,a.kt)("inlineCode",{parentName:"p"},"bar@1.0.0/node_modules"),"."),(0,a.kt)("p",null,"A great bonus of this layout is that only packages that are really in the dependencies are accessible. With a flattened ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules"),' structure, all hoisted packages are accessible. To read more about why this is an advantage, see "',(0,a.kt)("a",{parentName:"p",href:"https://www.kochan.io/nodejs/pnpms-strictness-helps-to-avoid-silly-bugs.html"},"pnpm's strictness helps to avoid silly bugs"),'"'))}k.isMDXComponent=!0}}]);